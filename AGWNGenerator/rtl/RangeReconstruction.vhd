-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\HDLAWGNGenerator\RangeReconstruction.vhd
-- Created: 2021-11-25 00:36:10
-- 
-- Generated by MATLAB 9.11 and HDL Coder 3.19
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: RangeReconstruction
-- Source Path: HDLAWGNGenerator/AWGNGenerator/GaussianNoiseWithUnitVar/SqrtImplementation/SqrtEval/RangeReconstruction
-- Hierarchy Level: 4
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY RangeReconstruction IS
  PORT( y_f                               :   IN    std_logic_vector(16 DOWNTO 0);  -- ufix17_En13
        pass                              :   IN    std_logic_vector(8 DOWNTO 0);  -- sfix9
        exp_f                             :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
        f                                 :   OUT   std_logic_vector(16 DOWNTO 0)  -- ufix17_En13
        );
END RangeReconstruction;


ARCHITECTURE rtl OF RangeReconstruction IS

  -- Signals
  SIGNAL pass_signed                      : signed(8 DOWNTO 0);  -- sfix9
  SIGNAL exp_f_signed                     : signed(7 DOWNTO 0);  -- int8
  SIGNAL Constant_out1                    : signed(7 DOWNTO 0);  -- int8
  SIGNAL Add_out1                         : signed(7 DOWNTO 0);  -- int8
  SIGNAL Switch_out1                      : signed(7 DOWNTO 0);  -- int8
  SIGNAL Shift_Arithmetic_out1            : signed(7 DOWNTO 0);  -- int8
  SIGNAL Gain_in0                         : signed(8 DOWNTO 0);  -- sfix9
  SIGNAL Gain_cast                        : signed(15 DOWNTO 0);  -- sfix16_En7
  SIGNAL Gain_out1                        : signed(7 DOWNTO 0);  -- int8
  SIGNAL shift_arithmetic1_shift_direction : std_logic;
  SIGNAL y_f_unsigned                     : unsigned(16 DOWNTO 0);  -- ufix17_En13
  SIGNAL shift_arithmetic1_abs_y          : signed(8 DOWNTO 0);  -- sfix9
  SIGNAL shift_arithmetic1_shift_value    : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL shift_right_cast                 : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL shift_arithmetic1_right          : unsigned(16 DOWNTO 0);  -- ufix17_En13
  SIGNAL shift_left_cast                  : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL shift_arithmetic1_left           : unsigned(16 DOWNTO 0);  -- ufix17_En13
  SIGNAL Shift_Arithmetic1_out1           : unsigned(16 DOWNTO 0);  -- ufix17_En13

BEGIN
  pass_signed <= signed(pass);

  exp_f_signed <= signed(exp_f);

  Constant_out1 <= to_signed(16#01#, 8);

  Add_out1 <= Constant_out1 + exp_f_signed;

  
  Switch_out1 <= exp_f_signed WHEN pass_signed = to_signed(16#000#, 9) ELSE
      Add_out1;

  Shift_Arithmetic_out1 <= SHIFT_RIGHT(Switch_out1, 1);

  Gain_in0 <=  - (resize(Shift_Arithmetic_out1, 9));
  Gain_cast <= Gain_in0 & '0' & '0' & '0' & '0' & '0' & '0' & '0';
  Gain_out1 <= Gain_cast(14 DOWNTO 7);

  
  shift_arithmetic1_shift_direction <= '1' WHEN Gain_out1 < to_signed(16#00#, 8) ELSE
      '0';

  y_f_unsigned <= unsigned(y_f);

  
  shift_arithmetic1_abs_y <=  - (resize(Gain_out1, 9)) WHEN Gain_out1 < to_signed(16#00#, 8) ELSE
      resize(Gain_out1, 9);
  shift_arithmetic1_shift_value <= unsigned(shift_arithmetic1_abs_y);

  shift_right_cast <= resize(shift_arithmetic1_shift_value, 16);
  shift_arithmetic1_right <= SHIFT_RIGHT(y_f_unsigned, to_integer(shift_right_cast));

  shift_left_cast <= resize(shift_arithmetic1_shift_value, 16);
  shift_arithmetic1_left <= y_f_unsigned sll to_integer(shift_left_cast);

  
  Shift_Arithmetic1_out1 <= shift_arithmetic1_right WHEN shift_arithmetic1_shift_direction = '0' ELSE
      shift_arithmetic1_left;

  f <= std_logic_vector(Shift_Arithmetic1_out1);

END rtl;

