-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\HDLAWGNGenerator\RangeReduction.vhd
-- Created: 2021-11-25 00:36:10
-- 
-- Generated by MATLAB 9.11 and HDL Coder 3.19
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: RangeReduction
-- Source Path: HDLAWGNGenerator/AWGNGenerator/GaussianNoiseWithUnitVar/SqrtImplementation/SqrtEval/RangeReduction
-- Hierarchy Level: 4
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY RangeReduction IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        u                                 :   IN    std_logic_vector(30 DOWNTO 0);  -- ufix31_En24
        x_f                               :   OUT   std_logic_vector(30 DOWNTO 0);  -- ufix31_En24
        pass                              :   OUT   std_logic_vector(8 DOWNTO 0);  -- sfix9
        exp_f                             :   OUT   std_logic_vector(7 DOWNTO 0)  -- int8
        );
END RangeReduction;


ARCHITECTURE rtl OF RangeReduction IS

  -- Component Declarations
  COMPONENT leadingZeroDetector
    PORT( x                               :   IN    std_logic_vector(37 DOWNTO 0);  -- ufix38_En31
          exp_f                           :   OUT   std_logic_vector(7 DOWNTO 0)  -- uint8
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : leadingZeroDetector
    USE ENTITY work.leadingZeroDetector(rtl);

  -- Signals
  SIGNAL Constant_out1                    : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Delay3_out1                      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL u_unsigned                       : unsigned(30 DOWNTO 0);  -- ufix31_En24
  SIGNAL Data_Type_Conversion_out1        : unsigned(37 DOWNTO 0);  -- ufix38_En31
  SIGNAL Shift_Arithmetic2_out1           : unsigned(37 DOWNTO 0);  -- ufix38_En31
  SIGNAL exp_f_1                          : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL exp_f_unsigned                   : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Delay4_out1                      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Add_sub_cast                     : signed(8 DOWNTO 0);  -- sfix9
  SIGNAL Add_sub_cast_1                   : signed(8 DOWNTO 0);  -- sfix9
  SIGNAL Add_sub_temp                     : signed(8 DOWNTO 0);  -- sfix9
  SIGNAL Add_out1                         : signed(7 DOWNTO 0);  -- int8
  SIGNAL Shift_Arithmetic3_out1           : signed(7 DOWNTO 0);  -- int8
  SIGNAL Shift_Arithmetic4_out1           : signed(7 DOWNTO 0);  -- int8
  SIGNAL Subtract_out1                    : signed(8 DOWNTO 0);  -- sfix9
  SIGNAL shift_arithmetic_shift_direction : std_logic;
  SIGNAL Delay2_out1                      : unsigned(30 DOWNTO 0);  -- ufix31_En24
  SIGNAL shift_arithmetic_abs_y           : signed(8 DOWNTO 0);  -- sfix9
  SIGNAL shift_arithmetic_shift_value     : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL shift_right_cast                 : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL shift_arithmetic_right           : unsigned(30 DOWNTO 0);  -- ufix31_En24
  SIGNAL shift_left_cast                  : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL shift_arithmetic_left            : unsigned(30 DOWNTO 0);  -- ufix31_En24
  SIGNAL x_f1                             : unsigned(30 DOWNTO 0);  -- ufix31_En24
  SIGNAL Shift_Arithmetic1_out1           : unsigned(30 DOWNTO 0);  -- ufix31_En24
  SIGNAL Switch_out1                      : unsigned(30 DOWNTO 0);  -- ufix31_En24

BEGIN
  -- Range of x_f=[1,4)

  u_leadingZeroDetector : leadingZeroDetector
    PORT MAP( x => std_logic_vector(Shift_Arithmetic2_out1),  -- ufix38_En31
              exp_f => exp_f_1  -- uint8
              );

  Constant_out1 <= to_unsigned(16#05#, 8);

  Delay3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay3_out1 <= to_unsigned(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      Delay3_out1 <= Constant_out1;
    END IF;
  END PROCESS Delay3_process;


  u_unsigned <= unsigned(u);

  Data_Type_Conversion_out1 <= u_unsigned & '0' & '0' & '0' & '0' & '0' & '0' & '0';

  Shift_Arithmetic2_out1 <= SHIFT_RIGHT(Data_Type_Conversion_out1, 6);

  exp_f_unsigned <= unsigned(exp_f_1);

  Delay4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay4_out1 <= to_unsigned(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      Delay4_out1 <= exp_f_unsigned;
    END IF;
  END PROCESS Delay4_process;


  Add_sub_cast <= signed(resize(Delay3_out1, 9));
  Add_sub_cast_1 <= signed(resize(Delay4_out1, 9));
  Add_sub_temp <= Add_sub_cast - Add_sub_cast_1;
  Add_out1 <= Add_sub_temp(7 DOWNTO 0);

  Shift_Arithmetic3_out1 <= SHIFT_RIGHT(Add_out1, 1);

  Shift_Arithmetic4_out1 <= Shift_Arithmetic3_out1 sll 1;

  Subtract_out1 <= resize(Add_out1, 9) - resize(Shift_Arithmetic4_out1, 9);

  
  shift_arithmetic_shift_direction <= '1' WHEN Add_out1 < to_signed(16#00#, 8) ELSE
      '0';

  Delay2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay2_out1 <= to_unsigned(16#00000000#, 31);
    ELSIF clk'EVENT AND clk = '1' THEN
      Delay2_out1 <= u_unsigned;
    END IF;
  END PROCESS Delay2_process;


  
  shift_arithmetic_abs_y <=  - (resize(Add_out1, 9)) WHEN Add_out1 < to_signed(16#00#, 8) ELSE
      resize(Add_out1, 9);
  shift_arithmetic_shift_value <= unsigned(shift_arithmetic_abs_y);

  shift_right_cast <= resize(shift_arithmetic_shift_value, 16);
  shift_arithmetic_right <= SHIFT_RIGHT(Delay2_out1, to_integer(shift_right_cast));

  shift_left_cast <= resize(shift_arithmetic_shift_value, 16);
  shift_arithmetic_left <= Delay2_out1 sll to_integer(shift_left_cast);

  
  x_f1 <= shift_arithmetic_right WHEN shift_arithmetic_shift_direction = '0' ELSE
      shift_arithmetic_left;

  Shift_Arithmetic1_out1 <= SHIFT_RIGHT(x_f1, 1);

  
  Switch_out1 <= x_f1 WHEN Subtract_out1 = to_signed(16#000#, 9) ELSE
      Shift_Arithmetic1_out1;

  x_f <= std_logic_vector(Switch_out1);

  pass <= std_logic_vector(Subtract_out1);

  exp_f <= std_logic_vector(Add_out1);

END rtl;

